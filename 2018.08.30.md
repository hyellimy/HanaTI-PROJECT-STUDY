# 2018.08.30



### Component클래스

#### [복습]

##### 생성자와 메서드, Component는 java.awt 패키지의 최상위 클래스로 모든 UI컴포넌트들이 가지는 공통적인 속성과 기능을 제공하는 추상클래스이다. 

| 생성자                         |                                |
| ------------------------------ | ------------------------------ |
| Component ( )                  |                                |
| 메서드                         |                                |
| public void add(PopupMenu pop) | 컴포넌트에 팝업 메뉴 추가      |
| public Color getBackground()   | 컴포넌트 배경색 반환           |
| public Color getForeground()   | 컴포넌트 전경색 반환           |
| public Graphics getGraphics()  | 컴포넌트 Graphic 객체 반환     |
| public String getName()        | 컴포넌트 이름 반환             |
| public Container getParent()   | 부모 컨테이너 반환             |
| public Dimension getSize()     | 컴포넌트 크기 반환             |
| public boolean isEnabled()     | 컴포넌트 활성 여부 반환        |
| public boolean isVisible()     | 컴포넌트 화면 보이기 여부 반환 |

| public void remove(MenuComponent com)        | 팝업 메뉴 제거                |
| -------------------------------------------- | ----------------------------- |
| public void repaint()                        | 컴포넌트 다시 그리기          |
| public setBackground(Color color)            | 컴포넌트 바탕색 지정          |
| public setEnabled(boolean b)                 | 컴포넌트 활성 여부 지정       |
| public setFont(Font f)                       | 컴포넌트 폰트 설정            |
| public setLocation(int x, int   y)           | 컴포넌트 위치 설정            |
| public setSize(int w, int h)                 | 컴포넌트 크기 설정            |
| public setBounds(int x, int y, int w, int h) | 컴포넌트 위치와 크기 설정     |
| public setVisible(boolean b)                 | 컴포넌트 화면에 보이도록 설정 |

- 모든 컴포넌츠는 set Size가 있다. 
- IsEnable! 활성화 되어있나?

- 팝업메뉴 지우기 : public void remove

- ##### Font설정하기 실습해보기 !

```
connectB.setFont(new Font("궁서체", Font.BOLD,20 ));
		// new Font(글씨체, 스타일, 사이즈)
```

#### * 한글이 깨지지 않게 설정하는 방법!

AWT 현재 OS의 인코딩 방법으로 설정해주어야 한다. 

##### 설정방법: Run Configuration - Argument - VM arguments : -Dfile.encoding=MS949



#### * 화면이 중앙에 위치하도록 설정하기

- 맨 밑에서 하면 좋겠다 :) 

```
this.setLocation(100, 100); //가운데 지정해주기 
```



#### *화면을 정 중앙에 위치하게 하기

- 전체 화면의 길이를 알고 그 중앙값을 설정해야 한다. 
- setColorAll에서 중앙값을 먼저 설정한다. 

```
	public void setCenter() { //화면 정중앙 위치 찾기위해 일단 중앙지정
		Toolkit.getDefaultToolkit().beep(); //삡 소리가 난다.
		Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
		System.out.println(dim);// 하는이유 : 위치값 찾기
		
		int x = (dim.width - getSize().width)/2;
		int y = (dim.height - getSize().height)/2;
		setLocation(x,y);
		
```

```
메인함수에, 
	public static void main(String[] args) {
		frame.setCenter(); //메인함수에 가운데 설정한다고 말해주기
```



### Container 

##### - Component클래스의 서브클래스로, 비주얼 컴포넌트들을 등록하고 배치하기 위한 수직적 기능규약을 선언한 추상클래스이다. 

- 말그대로 컨테이너, 무엇인가를 담는 역할을 한다..

| 생성자                                      |                          |
| ------------------------------------------- | ------------------------ |
| Container ( )                               |                          |
| 메서드                                      |                          |
| public void add(Component comp)             | 컨테이너에 컴포넌트 추가 |
| public Component getComponent(int position) | 컴포넌트 반환            |
| public Component[] getComponents()          | 모든 컴포넌트들 반환     |
| public void remove(Component   comp)        | 컴포넌트 제거            |
| public void removeAll()                     | 모든 컴포넌트 제거       |
| public void setLayout(LayoutManager mgr)    | 배치관리자 설정          |

### Frame

-Frame은 윈도우 클래스의 서브클래스로 타이틀바, 최소, 최대, 종료버튼을 제공하는 외부 컨테이너 클래스이다. 

| 생성자                              |                          |
| ----------------------------------- | ------------------------ |
| public Frame ( )                    | 기본 생성자              |
| public Frame (String title)         | 타이틀바 문자열 설정     |
| 메서드                              |                          |
| public String getTitle()            | 타이틀바의 문자열 반환   |
| public boolean isResizable()        | 창의 크기 변경 여부 반환 |
| public void setMenuBar(MenuBar mb)  | 프레임에 메뉴 등록       |
| public void setResizable(boolean b) | 창의 크기 변경 여부 설정 |
| public void setTitle(String title)  | 타이틀바의 문자열 설정   |

#### 컴포넌트 내 색 넣기 방법 :)

```
		//컴포넌트 활성 여부의 지정 
//		connectB.setEnabled(false);
		//색넣기(바탕색 지정하기) : RGB
//		connectB.setBackground(new Color(255, 0, 0));
		//위에처럼 해도 되지만, 숫자 다 외우기 어렵다! color.색으로 지정하면 좋다.
		connectB.setBackground(Color.ORANGE); //컴포넌트 배경색 반환
		connectB.setForeground(Color.white); //컴포넌트 전경색 반환
```

#### 배치관리자로 LayoutManager 인터페이스를 구현한 5개의 클래스

- FlowLayout - Panel클래스의 디폴트 레이아웃매니저 :  창안에 작은 버튼 
- BorderLayout - Window 계열 클래스의 디폴트 레이아웃 매니저 : 창 전체 크기 
- GridLayout
- GridBagLayout
- CardLayout

#### [ChatFrame 클래스]

- 프레임을 안받고, 재상속은 Panel을 받는다. 
- 프레임으로 하면, 화면 채팅 화면은 내부적으로 사용할 수는 없다. 컨테이너 안에 컨테이너를 넣을 수 없기때문에, 화면 하나를 패널 하나로 본다. 

#### [GridPanel클래스]

- 해야 할 것 : 상속받는것을 panel로 설정해주기 
- 배열 3X3 크기의 버튼 만들기, 단추 9개  

```
import java.awt.Button;
import java.awt.Frame;
import java.awt.GridLayout;
import java.awt.Panel;

public class GridPanel extends Panel {
	Button[] buttons;
	public GridPanel() { //생성자만들기
		setLayout(new GridLayout(3,3));
		buttons = new Button[9]; //배열 9개 짜리 버튼 만들기 
		for (int i = 0; i < buttons.length; i++) {
			buttons[i] = new Button(i + "BUTTON");
			add(buttons[i]);
		}
		//단독적으로 화면에 나오지 않기 때문에 
		// 궂이 상속받은 프레임을 만들지 않아도 된다. 
	}
	public static void main(String[] args) {
		Frame frame = new Frame("GridLayout Example");
		GridPanel panel = new GridPanel();
		frame.add(panel);
		frame.setVisible(true);
		frame.setSize(400, 400);
	}
}
```

##### 응용) 버튼 100개 짜리 버튼만들기, 10X10

```
import java.awt.Button;
import java.awt.Frame;
import java.awt.GridLayout;
import java.awt.Panel;

public class GridPanel extends Panel {
	Button[] buttons;
	public GridPanel() { //생성자만들기
		setLayout(new GridLayout(10	,10));
		buttons = new Button[100]; //배열 9개 짜리 버튼 만들기 
		for (int i = 0; i < buttons.length; i++) {
			buttons[i] = new Button(i + "BUTTON");
			add(buttons[i]);
		}
		//단독적으로 화면에 나오지 않기 때문에 
		// 궂이 상속받은 프레임을 만들지 않아도 된다. 
	}
	public static void main(String[] args) {
		Frame frame = new Frame("GridLayout Example");
		GridPanel panel = new GridPanel();
		frame.add(panel);
		frame.setVisible(true);
		frame.setSize(1000, 1000);
	}
}
```

- 게임이나 계산기 만들기로 응용할 수 있다. 

##### 화면실습 만드는 방법 생각해보기

![1535592351183](C:\Users\KOSTA\AppData\Local\Temp\1535592351183.png)

- 받는사람, 첨부파일, 제목을 맨 위의 하나의 패널로 설정
- 그리드의 특징이 확 커지기때문에 만들게 되면,  버튼이 다 늘어나게 된다. 
- 화면은 누구든지 간섭하게 되기 때문에, 어렵다 ㅠㅠ

#### 실습해보기, GridBagLayout - LayoutManager

![1535592600996](C:\Users\KOSTA\AppData\Local\Temp\1535592600996.png)

- 격자의 순서 지정 가능하다. 
- (버튼0과 버튼1크기 합치기) 셀 합치기 기능 가능하다. 
- Resizing 할때 가중치 설정도 가능하다. 



### !!내일 과제!!

위에 화면만들기 실습 해야한다........ 할쑤있다!

파워포인트 4번, 배치관리자 보면서 실습 해볼 수 있다. 

과제를 위해 미리 실습! 화이팅!! 

![1535592949055](C:\Users\KOSTA\AppData\Local\Temp\1535592949055.png)

#### 실습) 버튼 한개 정중앙에 오도록 만들기 [클래스명:GirdBagLayoutPanel]

```
import java.awt.Button;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Panel;

public class GridBagLayoutPanel extends Panel {
	
	Button button1;
	GridBagLayout gridBagLayout;
	GridBagConstraints gridBagConstraints;
	
	public GridBagLayoutPanel() {
		button1 = new Button("Button1");
		gridBagLayout = new GridBagLayout();
		gridBagConstraints = new GridBagConstraints();
		
	}
	public void setContents() {
		setLayout(gridBagLayout);
		//버튼을 붙이기 전에, 버튼을 위한 설정이 필요함
		//그리드 컨스트레인츠 
		gridBagConstraints.gridx = 0;
		gridBagConstraints.gridy = 0;
		gridBagConstraints.gridwidth = 1;
		gridBagConstraints.gridheight = 1;
		
		gridBagLayout.setConstraints(button1, gridBagConstraints); //버튼 1을 gridbagConstraints 설정으로 붙여주세요
		add(button1);
	}
	public static void main(String[] args) {
		Frame frame = new Frame("GridBagLayout Example");
		GridBagLayoutPanel panel = new GridBagLayoutPanel();
		panel.setContents();
		
		frame.add(panel);
		frame.setVisible(true);
		frame.setSize(400, 400);		
		// 결과 프레임을 유지하면서 정중앙에 버튼 위치한다.
	}
}
```

#### 응용1 ) 버튼 2개짜리 만들기 

- 이전에 한 설정에 버튼 2 추가하고, X좌표에 1 늘려주는 버튼 2를 만든다.
- 양옆에 나란히 존재하는 버튼 1과 2를 만들어줄 수 있다. 

```
import java.awt.Button;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Panel;

public class GridBagLayoutPanel extends Panel {
	
	Button button1, button2;
	GridBagLayout gridBagLayout;
	GridBagConstraints gridBagConstraints;
	
	public GridBagLayoutPanel() {
		button1 = new Button("Button1");
		button2 = new Button("Button2");
		gridBagLayout = new GridBagLayout();
		gridBagConstraints = new GridBagConstraints();
		
	}
	public void setContents() {
		setLayout(gridBagLayout);
		//버튼을 붙이기 전에, 버튼을 위한 설정이 필요함
		//그리드 컨스트레인츠 
		gridBagConstraints.gridx = 0;
		gridBagConstraints.gridy = 0;
		gridBagConstraints.gridwidth = 1;
		gridBagConstraints.gridheight = 1;
		
		gridBagLayout.setConstraints(button1, gridBagConstraints); //버튼 1을 gridbagConstraints 설정으로 붙여주세요
		add(button1);

		//버튼 1 옆에 위치하도록 만들거당! 
		gridBagConstraints.gridx = 1;
		gridBagConstraints.gridy = 0;
		gridBagConstraints.gridwidth = 1;
		gridBagConstraints.gridheight = 1;
		
		gridBagLayout.setConstraints(button2, gridBagConstraints); //버튼 1을 gridbagConstraints 설정으로 붙여주세요
		add(button2);

	
	}
	public static void main(String[] args) {
		Frame frame = new Frame("GridBagLayout Example");
		GridBagLayoutPanel panel = new GridBagLayoutPanel();
		panel.setContents();
		
		frame.add(panel);
		frame.setVisible(true);
		frame.setSize(400, 400);		
		// 결과 프레임을 유지하면서 정중앙에 버튼 위치한다.
	}
}
```

#### 응용2) 버튼에 Weight라는 속성 추가해주기 (결과 !버튼이 떨어진다!)

```
import java.awt.Button;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Panel;

public class GridBagLayoutPanel extends Panel {
	
	Button button1, button2;
	GridBagLayout gridBagLayout;
	GridBagConstraints gridBagConstraints;
	
	public GridBagLayoutPanel() {
		button1 = new Button("Button1");
		button2 = new Button("Button2");
		gridBagLayout = new GridBagLayout();
		gridBagConstraints = new GridBagConstraints();
		
	}
	public void setContents() {
		setLayout(gridBagLayout);
		//버튼을 붙이기 전에, 버튼을 위한 설정이 필요함
		//그리드 컨스트레인츠 
		gridBagConstraints.gridx = 0;
		gridBagConstraints.gridy = 0;
		gridBagConstraints.gridwidth = 1;
		gridBagConstraints.gridheight = 1;
		gridBagConstraints.weightx = 1; //가중치 설정해주기
		gridBagConstraints.weighty = 1; //가중치 y 설정 
		
		gridBagLayout.setConstraints(button1, gridBagConstraints); //버튼 1을 gridbagConstraints 설정으로 붙여주세요
		add(button1);

		//버튼 1 옆에 위치하도록 만들거당! 
		gridBagConstraints.gridx = 1;
		gridBagConstraints.gridy = 0;
		gridBagConstraints.gridwidth = 1;
		gridBagConstraints.gridheight = 1;
		
		gridBagLayout.setConstraints(button2, gridBagConstraints); //버튼 1을 gridbagConstraints 설정으로 붙여주세요
		add(button2);

	
	}
	public static void main(String[] args) {
		Frame frame = new Frame("GridBagLayout Example");
		GridBagLayoutPanel panel = new GridBagLayoutPanel();
		panel.setContents();
		
		frame.add(panel);
		frame.setVisible(true);
		frame.setSize(400, 400);		
		// 결과 프레임을 유지하면서 정중앙에 버튼 위치한다.
	}
}
```

- 이전에 설정했던 버튼의 여백을 격자가 차지한다.  

- 1이라고 설정한 값 = 분모가 된다. 

- 첫번째 격자의 여백을 차지하는 가중치는 (자신이 지정한 가중치 1 / 1+1이 분모) = 1/2

- 나머지 여분을 첫번째 버튼의 여백을 공유할 수 있도록 해야한다. 

- ##### 응용) button1값은 그대로 두고, button2의 값 변화시켜보자, weight x = 0 , wiegth   y= 0는 맨 오른쪽으로 간다. 이유? 가중치가 button1에만 주어졌기 때문에 화면을 아무리 움직여도 버튼 1이 중심으로 화면이 움직인다. 

```
	gridBagConstraints.fill = gridBagConstraints.HORIZONTAL; 
```

- 위아래에 여백을 주고 싶다면? 

```
		//위아래 여백을 주고 싶다 Inset(위, 아래, 좌, 우)
		gridBagConstraints.insets = new Insets(5, 5, 5, 5);
```

#### 컴포너츠 넣어주기

```
	} 버튼 위치 지정해주기
    	add(button1, 0, 0, 1, 1, 0, 0);
		add(button2, 1, 0, 1, 1, 1, 0);
	}

//컴포너츠 넣어주기 
	private void add(Component Component, int gridx, int gridy, int gridwidth, int gridheight, double weightx,
			double weighty) {
		gridBagConstraints.gridx = gridx;
		gridBagConstraints.gridy = gridy;
		gridBagConstraints.gridwidth = gridwidth;
		gridBagConstraints.gridheight = gridheight;
		gridBagConstraints.weightx = weightx;
		gridBagConstraints.weighty = weighty;
		gridBagConstraints.fill = gridBagConstraints.HORIZONTAL;

		gridBagLayout.setConstraints(Component, gridBagConstraints); 
		add(Component);

	}
```

결과값 : 1 반, 2, 큰 버튼 .

#### 가로로 넓은 버튼 2개 만들기

```
import java.awt.Button;
import java.awt.Component;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Panel;

public class GridBagLayoutPanel extends Panel {

	Button button1, button2;
	GridBagLayout gridBagLayout;
	GridBagConstraints gridBagConstraints;

	public GridBagLayoutPanel() {
		button1 = new Button("Button1");
		button2 = new Button("Button2");
		gridBagLayout = new GridBagLayout();
		gridBagConstraints = new GridBagConstraints();

	}

	public void setContents() {
		setLayout(gridBagLayout);
		add(button1, 0, 0, 1, 1, 0, 0);
		add(button2, 1, 0, 1, 1, 1, 0);
	}
	//컴포너츠 넣어주기 
	private void add(Component Component, int gridx, int gridy, int gridwidth, int gridheight, double weightx,
			double weighty) {
		gridBagConstraints.gridx = gridx;
		gridBagConstraints.gridy = gridy;
		gridBagConstraints.gridwidth = gridwidth;
		gridBagConstraints.gridheight = gridheight;
		gridBagConstraints.weightx = weightx;
		gridBagConstraints.weighty = weighty;
		gridBagConstraints.fill = gridBagConstraints.HORIZONTAL;

		gridBagLayout.setConstraints(Component, gridBagConstraints); 
		add(Component);
	}

	public static void main(String[] args) {
		Frame frame = new Frame("GridBagLayout Example");
		GridBagLayoutPanel panel = new GridBagLayoutPanel();
		panel.setContents();

		frame.add(panel);
		frame.setVisible(true);
		frame.setSize(400, 400);
		// 결과 프레임을 유지하면서 정중앙에 버튼 위치한다.
	}
}

```

#### 질문사항

- Grid Height - 붙어야지만 의미가 있다. 붙어야지만 격자가 생기는 것이다.  따라서 현재,  양옆으로 2개 있는 상태에서 gridheight는 의미가 없다. 따라서 버튼 3을 만들어본다. 
- 이해가 안되면, 엑셀 화면에 미리 만들어보면 된다 :)  훨씬 계산하기 쉽다.

#### 예제 문제 미리 만들어보기, 버튼 1-2-3까지 만들었다!

```
import java.awt.Button;
import java.awt.Component;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Panel;

public class GridBagLayoutPanel extends Panel {

	Button button1, button2, button3;
	GridBagLayout gridBagLayout;
	GridBagConstraints gridBagConstraints;

	public GridBagLayoutPanel() {
		button1 = new Button("Button1");
		button2 = new Button("Button2");
		button3 = new Button("Button3");
		gridBagLayout = new GridBagLayout();
		gridBagConstraints = new GridBagConstraints();

	}

	public void setContents() {
		setLayout(gridBagLayout);
		add(button1, 0, 0, 1, 1, 1, 0);
		add(button2, 1, 0, 1, 1, 1, 0);
		add(button3, 0, 1, 2, 2, 1, 0);
	}
	//컴포너츠 넣어주기 
	private void add(Component Component, int gridx, int gridy, int gridwidth, int gridheight, double weightx,
			double weighty) {
		gridBagConstraints.gridx = gridx;
		gridBagConstraints.gridy = gridy;
		gridBagConstraints.gridwidth = gridwidth;
		gridBagConstraints.gridheight = gridheight;
		gridBagConstraints.weightx = weightx;
		gridBagConstraints.weighty = weighty;
		gridBagConstraints.fill = gridBagConstraints.HORIZONTAL;

		gridBagLayout.setConstraints(Component, gridBagConstraints); 
		add(Component);
	}

	public static void main(String[] args) {
		Frame frame = new Frame("GridBagLayout Example");
		GridBagLayoutPanel panel = new GridBagLayoutPanel();
		panel.setContents();

		frame.add(panel);
		frame.setVisible(true);
		frame.setSize(400, 400);
		// 결과 프레임을 유지하면서 정중앙에 버튼 위치한다.
	}
}

```

- 격자가 없으면 아무런 의미가 없다는 것. 

#### VERTICAL로 바꿔보면,  변화가 하나도 없다 왜!!!?

- => 가중치가 0이기 때문이다. 가중치가 없으면 공백을 차지하지 않겠다는 것이다.
- 어떻게 해서든 가중치를 주어야 한다. 

```
		gridBagConstraints.fill = gridBagConstraints.HORIZONTAL;
		=> 주로 가로로 비중을 많이 준다. 
```

```
		gridBagConstraints.fill = gridBagConstraints.BOTH;
		=> 양쪽으로 가중치를 같이 주려면? 
```

#### 버튼 크기를 화면에 꽉 차게 만들어주는 함수

```
	frame.pack();
	
	지울것 : frame.setSize(400,400);
```

### CardLayout- LayoutManager

![1535596527644](C:\Users\KOSTA\AppData\Local\Temp\1535596527644.png)

##### 이벤트를 배워야 활용가능하다. 나중에 이벤트 배우고 다시 수업할 예정입니당! :)



## 2. AWT 컴포넌트의 이벤트처리

인터페이스를 가장 잘 활용한 방법이다. 

#### 이벤트란?

- 프로그램과 사용가 간의 상호작용을 위해서 사용자가 키보드나 마우스 등의 장치를 통해서 응용 프로그램에 어떤 요구를 하는 사건을 말한다.

#### 이벤트 소스란?

- 버튼이나 텍스트 입력사항과 같이 이벤트가 발생한 컴포넌스 인스턴스를 말한다. 
- 이벤트가 발생하는 컴포넌트, 버튼을 클릭했으면 이벤트 소스라고 한다. 
- 사용자가 클릭하면 이벤트가 발생한 것이다. 해당 이벤트를 추상화하여 이벤트 객차라고 지정해준다. 
- 마우스로 누르면, 이벤트 발생한다. (마우스이벤트) , 메모리에 마우스 이벤트가 할당된 것
- 클래스를 만들어서 이벤트 를 받아들이는 이벤트 리스너가  필요하다.  (그 이름을 마우스 리스너 )라고 해줄 수 있다. 

![1535596735719](C:\Users\KOSTA\AppData\Local\Temp\1535596735719.png)

[배워야 할 것]

- 화면에 활력을 불어넣어 주는 것이다. :)
- 자바는 위힘형 , 1) 캡슐화 할 수 있는 것  OR 2) 이벤트 처리 
- ![1535597547346](C:\Users\KOSTA\AppData\Local\Temp\1535597547346.png)

```
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.FlowLayout;
import java.awt.Frame;

/**
 * 메인이 필요 없다. 다 들어와 있는 것!
 * @author 이혜림
 *
 */
public class UserFrame extends Frame { //유저프레임이 프레임상속받음

//	String title; 초기화 시키지 않은 것 

	// 인스턴스 변수만들기
	Button eButton, wButton, sButton, nButton, cButton;  //east, west, south, north, center

	// 생성자 만들기
	public UserFrame() { // 복합관계를 나타낸것
		this("이름없음");
	}

	public UserFrame(String title) { // 복합관계를 나타낸것
		super(title);
		this.eButton = new Button("EAST");
		this.wButton = new Button("WEST");
		this.sButton = new Button("SOUTH");
		this.nButton = new Button("NORTH");
		this.cButton = new Button("CENTER");
	
		
		// 복합을 생성한것.
	}
	
	//화면 배치
	public void setContents() {
		//레이아웃매니저 교체
		setLayout(new FlowLayout()); //flow 이기 때문에 물흐르듯이  나온다. ~~!!
		add(eButton, BorderLayout.EAST); //위치지정 
		add(wButton, BorderLayout.WEST); //위치지정 
		add(sButton, BorderLayout.SOUTH); //위치지정 
		add(nButton, BorderLayout.NORTH); //위치지정 
		add(cButton, BorderLayout.CENTER); //위치지정 
	}						//유지보수 하기 편리하게 만들었다 ~:)
	
	public static void main(String[] args) {
		//프레임생성하고 , 프레임이 구성하는 사이즈 
		UserFrame frame = new UserFrame("윈도우 타이틀입니다.."); // 가로안의 따옴표로 이름지정 
	//아직 add는 되지 않았지만, 
		frame.setContents();
		frame.setSize(800, 600); // 사이즈 지정 해주기 
		frame.setVisible(true);  //외부에서 제어해주는것 
	}
		
}
```

- 이전에 한 내용이다. 여기에 마우스 리스너를 추가한 이벤트를 지정!!
-  EAST버튼을 누르면,  마우스 클릭되었습니다. 라는 것이 나오도록 다시 변경해보기 

```
위에 퍼블릭 지정
public class UserFrame extends Frame implements MouseListener{ //유저프레임이 프레임상속받음

```

```
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

/**
 * 메인이 필요 없다. 다 들어와 있는 것!
 * @author 이혜림
 *
 */
public class UserFrame extends Frame implements MouseListener{ //유저프레임이 프레임상속받음

//	String title; 초기화 시키지 않은 것 

	// 인스턴스 변수만들기
	Button eButton, wButton, sButton, nButton, cButton;  //east, west, south, north, center

	// 생성자 만들기
	public UserFrame() { // 복합관계를 나타낸것
		this("이름없음");
	}

	public UserFrame(String title) { // 복합관계를 나타낸것
		super(title);
		this.eButton = new Button("EAST");
		this.wButton = new Button("WEST");
		this.sButton = new Button("SOUTH");
		this.nButton = new Button("NORTH");
		this.cButton = new Button("CENTER");
	
		
		// 복합을 생성한것.
	}
	
	//화면 배치
	public void setContents() {
		//레이아웃매니저 교체
		setLayout(new FlowLayout()); //flow 이기 때문에 물흐르듯이  나온다. ~~!!
		add(eButton, BorderLayout.EAST); 
		add(wButton, BorderLayout.WEST); 
		add(sButton, BorderLayout.SOUTH);
		add(nButton, BorderLayout.NORTH);
		add(cButton, BorderLayout.CENTER); 
	
	}				
	public void eventRegist() {
		//이벤트 소스의 이벤트 리스너 연결하기 
		eButton.addMouseListener(this);
	}
	
	public static void main(String[] args) {
		//프레임생성하고 , 프레임이 구성하는 사이즈 
		UserFrame frame = new UserFrame("윈도우 타이틀입니다.."); // 가로안의 따옴표로 이름지정 
	//아직 add는 되지 않았지만, 
		frame.setContents();
		frame.eventRegist();
		frame.setSize(800, 600); 
		frame.setVisible(true);  
	}

	@Override
	public void mouseClicked(MouseEvent e) {
		System.out.println("마우스 클릭되었습니다..");
		
	}

	@Override
	public void mouseEntered(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mouseExited(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mousePressed(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mouseReleased(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}
}

```

#### 응용2) 버튼을 클릭할때마다 , 빨간색으로 버튼 변하게 바꾸기

```
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

/**
 * 메인이 필요 없다. 다 들어와 있는 것!
 * @author 이혜림
 *
 */
public class UserFrame extends Frame implements MouseListener{ //유저프레임이 프레임상속받음

//	String title; 초기화 시키지 않은 것 

	// 인스턴스 변수만들기
	Button eButton, wButton, sButton, nButton, cButton;  //east, west, south, north, center

	// 생성자 만들기
	public UserFrame() { // 복합관계를 나타낸것
		this("이름없음");
	}

	public UserFrame(String title) { // 복합관계를 나타낸것
		super(title);
		this.eButton = new Button("EAST");
		this.wButton = new Button("WEST");
		this.sButton = new Button("SOUTH");
		this.nButton = new Button("NORTH");
		this.cButton = new Button("CENTER");
		// 복합을 생성한것.
	}
	//화면 배치
	public void setContents() {
		//레이아웃매니저 교체
		setLayout(new FlowLayout()); //flow 이기 때문에 물흐르듯이  나온다. ~~!!
		add(eButton, BorderLayout.EAST); 
		add(wButton, BorderLayout.WEST); 
		add(sButton, BorderLayout.SOUTH);
		add(nButton, BorderLayout.NORTH);
		add(cButton, BorderLayout.CENTER); 
	}				
	public void eventRegist() {
		//이벤트 소스의 이벤트 리스너 연결하기 
		eButton.addMouseListener(this);
	}
	
	public static void main(String[] args) {
		//프레임생성하고 , 프레임이 구성하는 사이즈 
		UserFrame frame = new UserFrame("윈도우 타이틀입니다.."); // 가로안의 따옴표로 이름지정 
	//아직 add는 되지 않았지만, 
		frame.setContents();
		frame.eventRegist();
		frame.setSize(800, 600); 
		frame.setVisible(true);  
	}

	@Override
	public void mouseClicked(MouseEvent e) {
		Object eventSource = e.getSource(); //얘가 버튼이 되는 것이다. 
		Button button = (Button)eventSource;
		//다운캐스팅을 해주어서, 버튼을 만들어줘야 한다.
		button.setBackground(Color.red);
	}

	@Override
	public void mouseEntered(MouseEvent arg0) {

		
	}
	@Override
	public void mouseExited(MouseEvent arg0) {
		
	}
	@Override
	public void mousePressed(MouseEvent arg0) {

	}
	@Override
	public void mouseReleased(MouseEvent arg0) {
	}

}
```

#### 응용3 ) 버튼 클릭할때마다,  랜덤하게 색 변하게 지정하기 

```
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

/**
 * 메인이 필요 없다. 다 들어와 있는 것!
 * @author 이혜림
 *
 */
public class UserFrame extends Frame implements MouseListener{


	// 인스턴스 변수만들기
	Button eButton, wButton, sButton, nButton, cButton;  

	// 생성자 만들기
	public UserFrame() {
		this("이름없음");
	}

	public UserFrame(String title) { 
		super(title);
		this.eButton = new Button("EAST");
		this.wButton = new Button("WEST");
		this.sButton = new Button("SOUTH");
		this.nButton = new Button("NORTH");
		this.cButton = new Button("CENTER");
	
		
		// 복합을 생성한것.
	}
	
	//화면 배치
	public void setContents() {
		setLayout(new FlowLayout()); 
		add(eButton, BorderLayout.EAST); 
		add(wButton, BorderLayout.WEST); 
		add(sButton, BorderLayout.SOUTH);
		add(nButton, BorderLayout.NORTH);
		add(cButton, BorderLayout.CENTER); 
	
	}				
	public void eventRegist() {
		eButton.addMouseListener(this);
	}
	
	public static void main(String[] args) {
		UserFrame frame = new UserFrame("윈도우 타이틀입니다..");
		frame.setContents();
		
		frame.eventRegist();
		frame.setSize(800, 600); 
		frame.setVisible(true);  
	}

	@Override
	public void mouseClicked(MouseEvent e) {
		Object eventSource = e.getSource(); //얘가 버튼이 되는 것이다. 
		int r = (int)(Math.random()*256);
		int g = (int)(Math.random()*256);
		int b = (int)(Math.random()*256);
		Button button = (Button)eventSource;
		button.setBackground(new Color(r,g,b));
	}
	@Override
	public void mouseEntered(MouseEvent arg0) {

	}

	@Override
	public void mouseExited(MouseEvent arg0) {
		
	}
	@Override
	public void mousePressed(MouseEvent arg0) {
		
	}
	@Override
	public void mouseReleased(MouseEvent arg0) {

	}	
}
```

#### CALLBACK메소드

- 내가 구현하고 아는 것, 구조화되는 것을 모두 콜, 백 메소드로 변화시켜주는 것이다. 
- 자동화되어 실행되는 것이 필요 
- 이벤트 발생하면 사용자가 따로 호출하지 않음 JVM이벤트 발생 시 해당 메소드 자동호출

#### 질문사항

- 나머지 사항도 등록해주기 위해서는 이벤트 소스에 이벤트 리스너 연결에 5개 파일을 모두 생성해주어야 한다. 

```

	public void eventRegist() {
		// 이벤트 소스의 이벤트 리스너 연결하기
		eButton.addMouseListener(this);
		wButton.addMouseListener(this);
		sButton.addMouseListener(this);
		nButton.addMouseListener(this);
		cButton.addMouseListener(this);
	}
```

- 이렇게 추가해주면, 이벤트 발생하는 것이 눈에 보이니깐!  :)
- 근데 이렇게 하면, 모든 사항이 같게  변화한다.

#### 해결위해, 각 버튼을 분기시켜 작동하게 하려면?

```
	Object eventSource = e.getSource(); // 얘가 버튼이 되는 것이다.
```

이 내용을 변경시켜 주어야 한다. 

```
	public void mouseClicked(MouseEvent e) {
		Object eventSource = e.getSource(); // 얘가 버튼이 되는 것이다.
		int r = (int) (Math.random() * 256);
		int g = (int) (Math.random() * 256);
		int b = (int) (Math.random() * 256);
		Button button = (Button) eventSource;
		button.setBackground(new Color(r, g, b));
		
		if(eventSource == eButton) {
			System.out.println("EAST Button 클릭이요...");
		}else if(eventSource == wButton) {
			System.out.println("WEST Button 클릭이요");
		}else if(eventSource == sButton) {
			System.out.println("SOUTH Button클릭이요..");
		}
	}
```

#### 엑스 버튼 눌렀을 때, 창이 종료되는 이벤트 만들기!

- 리스너 이벤트 :  WindowListener -> 에러, 추상메소드 Userframe 의 add unimplemented method 추가하기 
- 에드 윈도우 리스너

```
	@Override
	public void windowClosing(WindowEvent e) { // 창 닫을때, 창 닫고 싶다면 이용해야 할 것
		setVisible(false); 
		dispose(); // os그래픽리소스 : AWT의 특징, OS로부터 기능을 넘겨와서, 운영체제를 C코드로 변화 - 반납해줄때 사용
		System.exit(0); //virtual 머신 종료


```

```
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;

/**
 * 메인이 필요 없다. 다 들어와 있는 것!
 * 
 * @author 이혜림
 *
 */
public class UserFrame extends Frame implements MouseListener, WindowListener { 


	Button eButton, wButton, sButton, nButton, cButton; 

	// 생성자 만들기
	public UserFrame() { 
		this("이름없음");
	}

	public UserFrame(String title) { 
		super(title);
		this.eButton = new Button("EAST");
		this.wButton = new Button("WEST");
		this.sButton = new Button("SOUTH");
		this.nButton = new Button("NORTH");
		this.cButton = new Button("CENTER");

	}

	// 화면 배치
	public void setContents() {
		setLayout(new FlowLayout()); // flow 이기 때문에 물흐르듯이 나온다. ~~!!
		add(eButton, BorderLayout.EAST);
		add(wButton, BorderLayout.WEST);
		add(sButton, BorderLayout.SOUTH);
		add(nButton, BorderLayout.NORTH);
		add(cButton, BorderLayout.CENTER);

	}

	public void eventRegist() {
		eButton.addMouseListener(this);
		wButton.addMouseListener(this);
		sButton.addMouseListener(this);
		nButton.addMouseListener(this);
		cButton.addMouseListener(this);
		addWindowListener(this);
	}

	public static void main(String[] args) {
		// 프레임생성하고 , 프레임이 구성하는 사이즈
		UserFrame frame = new UserFrame("윈도우 타이틀입니다.."); // 가로안의 따옴표로 이름지정
		// 아직 add는 되지 않았지만,
		frame.setContents();
		frame.eventRegist();
		frame.setSize(800, 600);
		frame.setVisible(true);
	}

	@Override
	public void mouseClicked(MouseEvent e) {
//		System.out.println("마우스 클릭되었습니다..");
		Object eventSource = e.getSource(); // 얘가 버튼이 되는 것이다.
		int r = (int) (Math.random() * 256);
		int g = (int) (Math.random() * 256);
		int b = (int) (Math.random() * 256);
		Button button = (Button) eventSource;
		button.setBackground(new Color(r, g, b));

		if (eventSource == eButton) {
			System.out.println("EAST Button 클릭이요...");
		} else if (eventSource == wButton) {
			System.out.println("WEST Button 클릭이요");
		} else if (eventSource == sButton) {
			System.out.println("SOUTH Button클릭이요..");
		}
	}

	@Override
	public void mouseEntered(MouseEvent e) {
		System.out.println("mouseEntered() Called...");
	}

	@Override
	public void mouseExited(MouseEvent e) {
		System.out.println("mouseEntered() Called...");

	}

	@Override
	public void mousePressed(MouseEvent e) {
		System.out.println("mouseEntered() Called...");

	}

	@Override
	public void mouseReleased(MouseEvent e) {
		System.out.println("mouseEntered() Called...");
	}

	@Override
	public void windowActivated(WindowEvent arg0) {
		// TODO Auto-generated method stub

	}

	@Override
	public void windowClosed(WindowEvent e) { // 리소스와 관련된 것이다
		// TODO Auto-generated method stub

	}

	@Override
	public void windowClosing(WindowEvent e) { // 창 닫을때, 창 닫고 싶다면 이용해야 할 것
		setVisible(false); 
		dispose(); // os그래픽리소스 : AWT의 특징, OS로부터 기능을 넘겨와서, 운영체제를 C코드로 변화 - 반납해줄때 사용
		System.exit(0); //virtual 머신 종료


	}

	@Override
	public void windowDeactivated(WindowEvent arg0) { // 창이 가려질때,
		// TODO Auto-generated method stub

	}
	@Override
	public void windowDeiconified(WindowEvent arg0) {

	}

	@Override
	public void windowIconified(WindowEvent arg0) {

	}
	@Override
	public void windowOpened(WindowEvent arg0) {
		System.out.println("창이 열렸습니다.");
	}
}
```

![1535616542257](C:\Users\KOSTA\AppData\Local\Temp\1535616542257.png)

### 이거 만드는거 실습 ;

```
import java.awt.Button;
import java.awt.Color;
import java.awt.Component;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Label;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;

public class GridBagLayoutPanel2 extends Panel {
   Button findB, sendB, cancelB;
   Label recipientL, attachmentL, titleL ;
   TextField recipipentTF, attachmentTF, titleTF;
   TextArea messageTA;
   GridBagLayout gridBagLayout;
   GridBagConstraints gridBagConstrains;

   
   public GridBagLayoutPanel2() {
      recipientL = new Label("받는사람");
      attachmentL = new Label("첨부파일");
      titleL = new Label("제목");
      recipipentTF = new TextField(10);
      attachmentTF = new TextField(10);
      titleTF = new TextField(10);
      
      messageTA = new TextArea(10,40);
      
      findB = new Button("찾기");
      sendB = new Button("보내기");
      cancelB = new Button("취소");
      gridBagLayout = new GridBagLayout();
      gridBagConstrains = new GridBagConstraints();   
   }
   
   public void setContents() {
      setLayout(gridBagLayout);

      add(recipientL,0,0,1,1,0,0);
      add(recipipentTF,1,0,2,1,0,0);

      add(attachmentL,0,1,1,1,0,0);
      add(attachmentTF,1,1,2,1,0,0);
      add(findB,3,1,1,1,0,0);
      
      Label label=new Label(" ");
      label.setBackground(Color.CYAN);
     
      add(label,4,1,1,1,0,0);   
      //add(label,5,1,1,1,0,0);   
      //add(label,6,1,1,1,0,0);
      
      /*
      add(new Label(" "),4,1,1,1,0,0);   
      add(new Label(" "),5,1,1,1,0,0);   
      add(new Label(" "),6,1,1,1,0,0);   
      */
    
      add(titleL,0,2,1,1,0,0);
      add(titleTF,1,2,6,1,0,0);
   
      add(messageTA,0,3,7,1,0,0);
     
     
      Panel panel = new Panel();
      panel.add(sendB);
      panel.add(cancelB);
      panel.setBackground(Color.BLUE);
      add(panel,0,4,7,1,0,0);
      
//      
//      add(new Label(" "),0,4,1,1,0,0);
//      add(new Label(" "),1,4,1,1,0,0);
//      
//      add(sendB,2,4,1,1,0,0);
//      add(cancelB,3,4,1,1,0,0);
//      add(new Label(" "),4,4,1,1,0,0);
//      add(new Label(" "),5,4,1,1,0,0);

     
      
   }
   private void add(Component component, int gridx, int gridy, int gridwidth, int gridheight, double weightx, double weighty) {

      gridBagConstrains.gridx = gridx;// 몇개의 격자를 차지할것인가
      gridBagConstrains.gridy = gridy;// 몇개의 격자를 차지할것인가 // 붙이면서 격자를 늘려가는것
      gridBagConstrains.gridheight = gridheight;
      gridBagConstrains.gridwidth = gridwidth;
      gridBagConstrains.weightx = weightx; 
      gridBagConstrains.weighty = weighty; 
      gridBagConstrains.fill = GridBagConstraints.HORIZONTAL;
      gridBagConstrains.insets = new Insets(5, 5, 5, 5);
      
      gridBagLayout.setConstraints(component, gridBagConstrains);
      add(component);
      
   }
  
   public static void main(String[] args) {
      Frame frame = new Frame("GridLayout Example");
      
      GridBagLayoutPanel2 panel = new GridBagLayoutPanel2() ;

      
      
      panel.setContents();
      frame.add(panel);
      frame.setVisible(true);
      
      frame.setSize(800,600);
//      frame.pack();// 버튼 안에 딱 넣어줌
   
   }
}
```



#### OOP 4대 특징

1. 추상화  2. 다형성  3. 상속 4. 캡슐화

- 

### 창 끄는 방법

```
public class TalkFrame extends Frame implements WindowListener{
	   //이거 실행시키는 방법,  임플리먼츠 눌르고, 추가하기 
	//추가하면 오버라이드 자동 삽입 가능
	// 그럼 윈도우 끄기 간으 
	
	   //종료기능
	   private void finish() {
		   setVisible(false); //컴포넌트를 보이지 않게 하는 것 
		   dispose();
		   System.exit(0);
	   }
		   
	   public static void main(String[] args) {
	      TalkFrame frame = new TalkFrame("Kotalk");
	      frame.setContents();
	      frame.setSize(300, 500);
	      frame.setCenter();
	      frame.eventRegist(); //추가해줌
	      frame.setVisible(true);
	   }
	   	}
	@Override
	public void windowClosing(WindowEvent arg0) {
		finish();
		
```



#### *주의해야할것!

Closed

Closing 차이  : 창 닫을때는 Clossing을 눌러야 된다. 

### 종료해주려면? WindowListener

```
public class TalkFrame extends Frame implements WindowListener{
  //종료기능
	   private void finish() {
		   setVisible(false); //컴포넌트를 보이지 않게 하는 것 
		   dispose();
		   System.exit(0);
	   }
	}
	@Override
	public void windowClosed(WindowEvent arg0) {
		 System.out.println("windowClosed() called...");
		
	}
	@Override
	public void windowClosing(WindowEvent arg0) {
		finish();
		
	}

```

```
ChatFrame 에 종료 기능 추가하기 + ExitHandeler 클래스 활용하기

[ChatFrame 클래스 생성 - WindowListener추가]
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;

public class ExitHandler implements WindowListener {

	ChatFrame Frame;
	public ExitHandler(ChatFrame frame) {
		this.Frame = frame;
		
	}
	
	
		@Override
	public void windowClosing(WindowEvent arg0) {
			Frame.finish();
	}
	
	
	
	[ChatFrame 변경사항]
	}
	
	public void finish() {
		setVisible(false);
		dispose();
		System.exit(0);
	}
	public void eventRegist() {
		addWindowListener(new ExitHandler(this));// 외부에서 나의 이름 참조할 수 있도록 
	}
	
```



### 누르면 나오는것? ActionListener 로그아웃 누르면 나오기!

```
	public class MainPanel extends Panel implements ActionListener{
	
	
	public MainPanel(TalkFrame frame) {
		this.frame = frame;
		tempL = new Label("This is Test Panel", Label.CENTER);
		logoutB = new Button("LOGOUT");
		setContents();
		logoutB.addActionListener(this); ////여기가 추가된거!!!!
	}
	
	
	
	@Override
	
	public void actionPerformed(ActionEvent arg0) {
		frame.changeCard("LOGIN");
	}

public static void main(String[] args) {
		// 프레임생성하고 , 프레임이 구성하는 사이즈
		ChatFrame frame = new ChatFrame("Kotalk"); // 가로안의 따옴표로 이름지정
		// 아직 add는 되지 않았지만,
		frame.setContents();
		frame.eventRegist(); //등록해주기!!! Exit기능 추가해주기 
		frame.setSize(600, 700); // 사이즈 지정 해주기
		frame.setVisible(true); // 외부에서 제어해주는것

		frame.setCenter(); // 메인함수에 가운데 설정한다고 말해주기

	}
}

```

### 이벤트 별 Adapter클래스

- 불필요한 메서드까지 오버라이딩 해야하는 단점을 극복하고자 나온 클래스가 어댑터 클래스이다. 
- 어뎁터 클래스는 이벤트 처리를 위해 필요한 메서드만 오버라이딩 하기 때문에,  불필요한 메서드까지의 오버라이딩의 불편함을 덜어준다. 
- 클래스는 다중상속을 지원하지 않기 때문에 이벤트 처리 클래스를 별도로 작성해야 한다. 



### 이너클래스(멤버내부클래스)

멤버 클래스 : 안에 숨어 있기 때문에 !!!

재사용성이 놓지 않고, 메모리에 할당되어 있어서 자원낭비,  -> 메소드 안에 이너클래스 만들기!



## 실습, ChatFrame에 내부클래스를 만들어서 종료 기능 추가하기

Exiter라는 내부 클래스를 생성하였다. 

```
	}
	public void eventRegist() {
		addWindowListener(new Exiter());// 아래, 멤버내부클래스를 추가한다. 
	}
	
	/** 멤버내부클래스를 이용한 처리*/
	class Exiter extends WindowAdapter {
		@Override 
		public void windowClosing(WindowEvent e) { //finalize는 오브젝트에 있는 것
			finish();
		}
		
	}
```



### 응용1) 

### 메소드 안에 이너클래스 만들기, 이름 있는 지역 내부클래스 

```
	public void eventRegist() {
		class Exiter extends WindowAdapter {
			@Override 
			public void windowClosing(WindowEvent e) { 
				finish();
		}
	}
	addWindowListener(new Exiter());
```

- 메소드 안에 직접 클래스를 넣어, 이름 있는 지역내부 클래스 생성가능

### 응용2) 이름 없는 지역내부클래스

```
//{}이것이, 이름 없는 지역내부클래스 		
	new WindowAdapter() {
	};								:: 바로 나온다! 
```

```
	addWindowListener(new WindowAdapter() { 
		@Override								//여기가 클래스 내용값이 된다.
		public void windowClosing(WindowEvent arg0) {
			finish();
		}
	});
```

### 응용3) ActionEvent구현하기

```
	// 입력된 값을 메세지에 입력시켜 주는 것
		inputTF.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent arg0) {
				String message = inputTF.getText();
				messageTA.append(message + "\n"); // 추가하면서 라인 바꿔주기
				inputTF.setText("");// ?
			}
		});
	}
```

## AWT Event종류

![1535678504366](C:\Users\KOSTA\AppData\Local\Temp\1535678504366.png)

- Componenet, Container : 거시적

* Focus : 텍스트 클릭되거나, 리스트 중 아이템 선택할때, 구체적으로 
* ItemEvent : 체크박스, 초이스, 리스트 
* KeyEvent  : 키보드로 입력 발생할 때 

* Mouse : 클릭, 누름 / MouseMotionEvent : 이동 동시에 발생
* TextEvent : 값이 입력될 때 발생하는 이벤트 



### KeyEvent활용

```
serverTF.addKeyListener(new KeyListener() {

			@Override
			public void keyPressed(KeyEvent e) {
				System.out.println(e.getKeyCode());
				System.out.println(KeyEvent.VK_ENTER);
				System.out.println(e.getKeyChar());
			}

			@Override
			public void keyReleased(KeyEvent e) {
				// TODO Auto-generated method stub

			}

			@Override
			public void keyTyped(KeyEvent e) {
				// TODO Auto-generated method stub

			}
		});

		inputTF.addTextListener(new TextListener() {

			@Override
			public void textValueChanged(TextEvent arg0) {
				System.out.println(inputTF.getText());
			}
		});
```



## XX Listener인터페이스 (가장 많이 사용 :-)

![1535678724939](C:\Users\KOSTA\AppData\Local\Temp\1535678724939.png)





## ItemEvent 예제 활용하기

1) GetStateChange() : 체크박스의 상태가 On 또는 Off상태인지 알기 위해

### 활용

```
		userList.addItemListener(new ItemListener() {

			@Override
			public void itemStateChanged(ItemEvent e) {
				if(e.getStateChange() == ItemEvent.SELECTED) {
					String name = userList.getSelectedItem();
				}
			}
			
		});
	}
```

###  응용1) 유저리스트 생성해서, 호출 될 수 있도록 만들기

```
	public ChatFrame(String title) { // 복합관계를 나타낸것
		super(title);
		serverL = new Label("서버");
		serverTF = new TextField(10);
		inputTF = new TextField(10);
		connectB = new Button("연결") {
			@Override
			public void paint(Graphics g) {
				g.drawLine(10, 10, 50, 10);
			}
		};
		sendB = new Button("SEND");
		messageTA = new TextArea(10, 30); 
		userList = new List(10); // 생성해주자!!!!!!!!!!!!!!!
		userList.add("말미잘");
		userList.add("꼴뚜기");
		userList.add("머저리");
		
		//아이템 리스너 활용하기 
		userList.addItemListener(new ItemListener() {

			@Override
			public void itemStateChanged(ItemEvent e) {
				if (e.getStateChange() == ItemEvent.SELECTED) {
					String name = userList.getSelectedItem();
					//showMessageDialog순서, (this. 메시지. 타이틀. 메시지 타이틀)
					JOptionPane.showMessageDialog(null, name+"님선택이요..", "알림", JOptionPane.INFORMATION_MESSAGE );
				}
			}
		
```

### 응용1+)  입력하고나서, 엔터 누르면, 화면에 입력되는 기능 추가

```

	// 입력된 값을 메세지에 입력시켜 주는 것
		inputTF.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent arg0) {
				String message = inputTF.getText();
				messageTA.append(message + "\n"); // 추가하면서 라인 바꿔주기
				inputTF.setText("");// ?
			}
		});
		
    serverTF.addKeyListener(new KeyListener() {

			@Override
			public void keyPressed(KeyEvent e) {
				System.out.println(e.getKeyCode());
				System.out.println(KeyEvent.VK_ENTER);
				System.out.println(e.getKeyChar());
			}

			@Override
			public void keyReleased(KeyEvent e) {
				// TODO Auto-generated method stub

			}

			@Override
			public void keyTyped(KeyEvent e) {
				// TODO Auto-generated method stub

			}
		});

		inputTF.addTextListener(new TextListener() {

			@Override
			public void textValueChanged(TextEvent arg0) {
				System.out.println(inputTF.getText());
			}
		});
```









### 응용2) OuterClass 안에 Inner Class 호출하는 두가지 방법

1) 그냥 일반적 (class - InnerClass) 

2) 직접적 호출 (static class SInnerCal )

```

public class OuterClass {

	enum Direction {
		A, B, C
	}

	class InnerClass {   
		public void foo() {
			System.out.println("foo 호출됨..");
		}
	}

	static class SInnerClass {
		public void bar() {
			System.out.println("bar 호출됨..");
		}
	}
}

```

```

public class InnerExample {

	public static void main(String[] args) {
//		OuterClass out = new OuterClass();

		OuterClass.InnerClass in = new OuterClass().new InnerClass();
		// 일만 Class호출은 new를 두번 다 붙여주어야 한다. 
		in.foo();

		OuterClass.SInnerClass in2 = new OuterClass.SInnerClass();
		//Static은 직접 호출이기 때문에, new한번만 하고 점으로 선언 가능
		in2.bar();

	}

}

```





생성시 버튼이 만들어 졌지만 그 메소드를 안쓰고,  즉흥적으로 활용하기 위해 

```
connectB = new Button("연결") {
			@Override
			public void paint(Graphics g) {
				g.drawLine(10, 10, 50, 10);
			}
		};
```































































































































